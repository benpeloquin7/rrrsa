---
title: "rrrsa"
author: "Ben Peloquin"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{summary}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Rational speech act model (RSA) of pragmatic inference

`rrrsa` is an R package for running RSA, a Bayesian model of pragmatic inference. rrrsa was created by Ben Peloquin.

## What is RSA?
Rational speech act (RSA) models frame language understanding as a special case of social cognition in which `speakers` and `listeners` reason about one another recursively. A `pragmatic listener` $P_{L_n}(m|u)$, reasons about intended meaning $m$ of an utterance $u$ by a `rational speaker` $P_{s_n}(u|m)$ who chooses an utterance according to the expected utility of an utterance $U(m;u)$. $\alpha$ is a decision noise parameter.

$$P_{L_n}(m|u) \propto P_{S_n}(u|m)P(m)$$
$$P_{S_n} \propto e^{U(m;u)}$$
$$U(m;u) = -\alpha(\log(P_{L_{n-1}}(m|u)) - C(u))$$

## rrrsa includes access to all model components
`rrrsa` provides users with access to all model components. The following sections demonstrate how this functionality can be used.

### Calculating the informativity an utterance
`rsa.informativity()` takes three arguments, literal semantics $P_{L_0}$, `alpha` level (default 1), and `cost` (default 0). This function returns the surprisal of an utterance minus cost, multiplied by alpha.
```{r}
library(rrrsa)
rsa.informativity(0.4)
rsa.informativity(rsa.informativity(0.4), alpha = 2, cost = 0.5)
```

### Calculating the utility of an utterance
`rsa.utility` takes an input vector of literal listener semantics and outputs a normalized vector of speaker likelihoods. If `costs` are not specified the default 0's vector is used. If `alpha` is not specified a default value of $1$ is used.
```{r}
literalSemantics <- c(0.0, 0.0, 0.3, 0.3, 0.4)
costs <- c(0.0, 0.0, 0.2, 0.3, 0.4)
rsa.utility(items = literalSemantics, costs = costs, alpha = 3)
```

### Computing one full recursion
In the RSA framework one full recursion consists of a `pragmatic listner` $P_{L_1}$ who reasons about a `rational speaker` $P_{s_1}$ who reason about a `literal listener` $P_{L_0}$. Expected input is an $m$ matrix of  $P_{L_0}$ `literal listener` values in which columns corresond to items (words) and rows correspond to semantic quantity (stars in Peloquin & Frank, 2016). Optional arguments include a `costs` vector which whould be the same length as `ncol` and an optional `priors` vector which should the same length as `nrows`. `rsa.fullRecursion` provides safety checking for these cases. Output corresponds with pragmatic listener posterior predictions.
```{r fig.height=8, fig.width=6}
library(ggplot2)
library(dplyr)
library(tidyr)

m <- matrix(data = c(1.0, 0.0, 0.0, 0.0, 0.0,
                     0.0, 0.25, 0.25, 0.25, 0.25,
                     0.0, 0.0, 0.0, 0.0, 1.0), nrow = 5)
colnames(m) <- c("none", "some", "all")
rownames(m) <- 1:5
# costs <- c("none" = 0, "some" = 0, "all" = 0)
# priors <- rnorm(n = nrow(m), mean = 0.5, sd = 0.1)
res <- rsa.fullRecursion(m = m)
res <- as.data.frame(res) %>%
  mutate(quantity = rownames(.))

pragmaticsTidied <- res %>%
  gather(word, pragmatics, -quantity)
semanticsTidied <- as.data.frame(m) %>%
  mutate(quantity = rownames(.)) %>%
  gather(word, semantics, c(none, some, all))
fullData <- merge(pragmaticsTidied, semanticsTidied) %>%
  gather(type, value, c(pragmatics, semantics)) %>%
  mutate(quantity = as.numeric(quantity),
         lineSize = ifelse(word == "some", 2, 1))

ggplot(fullData, aes(x = quantity, y = value, col = word)) +
  geom_line(aes(size=lineSize)) +
  facet_wrap(~type)

```

### Running multiple recursions
`rsa.reason` is really a wrapper function for `rsa.fullRecursion` which provides an additional `depth` parameter which specifies the recursive depth during reasoning. If depth is not provided, default value is $1$.
```{r}
all(rsa.reason(m = m, depth = 2) == rsa.fullRecursion(rsa.fullRecursion(m = m)))
rsa.reason(m = m, depth = 2)
```

### Running data frames
 Run RSA on a tidied data frame and avoid running individual model components individually with `rsa.runDf`. An RSA-ready, tidied data frame must contian columns for semantic `quantity`, `item` and `semantics`, where each row corresponds with unique `item`/`quantity` combination. A user should specify their naming convention for these items in the `quantityVarName`, `itemVarName` and `semanticsVarName` arguments. The `costVarName` and `priorsVarName` args correspond with `costs` and/or `priors` data. Users can specify values for `alpha` and `depth` hyperparamenters. `runDf` will return a data frame with a new model predictions `preds` column appended.

```{r}
## Hypothetical literal listener data we might want to compute RSA on.
df <- data.frame(scales = rep("some_all", 15),
                  stars = as.factor(rep(1:5, 3)),
                  starsChar = as.factor(rep(c("one", "two", "three", "four", "five"), 3)),
                  words = c(rep("all", 5), rep("some", 5), rep("none", 5)),
                  listenerSemantics = c(rep(0.0, 4), 1.0,
                                0.0, rep(0.25, 4),
                                1.0, rep(0.0, 4)))
rsa.runDf(df, quantityVarName = "stars", semanticsVarName = "listenerSemantics", itemVarName = "words")
```
Importantly, `runDf` maintains all column naming and can handle multiple data types. For example, we can run `runDf` with a character vector for `quantity` (contrast with the factor vector used above):
```{r}
all(rsa.runDf(df, quantityVarName = "starsChar",
              semanticsVarName = "listenerSemantics",
            itemVarName = "words") ==
       rsa.runDf(df, quantityVarName = "stars",
            semanticsVarName = "listenerSemantics",
            itemVarName = "words"))
```
A frequent use case for RSA will require running RSA over multiple groups of data. Rather than subsetting data frames and running RSA iteratively, we recommend using `ddply` from the `plyr` package. Users can supply the grouping variable in ddply's `.vars` argument
```{r message=FALSE}
library(dplyr)
df <- data.frame(scales = c(rep("some_all", 10), rep("good_excellent", 10)),
                  stars = as.factor(rep(1:5, 4)),
                  words = c(rep("all", 5), rep("some", 5), c(rep("excellent", 5), rep("good", 5))),
                  listenerSemantics = c(rep(0.0, 4), 1.0,
                                0.0, rep(0.25, 4),
                                rep(0.0, 4), 1.0,
                                0.0, rep(0.25, 4))) %>% mutate(priors = 0.20)
df$costs <- c(rep(3, 5), rep(4, 5), rep(9, 5), rep(4, 5))

tail(plyr::ddply(.data = df, .variables = c("scales"), rsa.runDf, quantityVarName = "stars",
      semanticsVarName = "listenerSemantics", itemVarName = "words", costsVarName = "costs", depth = 2), n = 3)
```
We can see this more clearly using data from Peloquin & Frank (2016). Here the grouping variable are different scalar familes (5 in total) named `scale`.
```{r}
d <- peloquinFrank_2Alts
head(plyr::ddply(.data = d, .variables = c("scale"), rsa.runDf, quantityVarName = "stars",
              semanticsVarName = "speaker.p", itemVarName = "words"), n = 3)
tail(plyr::ddply(.data = d, .variables = c("scale"), rsa.runDf, quantityVarName = "stars",
              semanticsVarName = "speaker.p", itemVarName = "words"), n = 3)
```

### Tuning hyperparamaters
If a user has `pragmatic judgment` data we can use the `tuneDepthAlpha` function to tune hyperparameters. Calling this function requires the same argument list as a simple `runDf` with the addition of `alphas` and `depths` vectors to iterate over as well as the column of `pragmatic judgments` specified through the `compareDataVarName` argument, which we'll be using as the basis of comparison.
```{r}
d <- peloquinFrank_5Alts
alphas <- seq(1, 5, by = 0.1)
depths <- 1:3
```
Users may also want to check only a subset of the items in their data frame for tuning. In the case of Peloquin & Frank (2016) we only wanted to tune against `entailment` pairs. The `compareItems` argument allows the user to pass a vector of items for subsetting.
```{r warning=FALSE}
checkWords <- c("some", "all", "good", "excellent", "liked", "loved", "memorable", "unforgettable",
                "palatable", "delicious")
results <- rsa.tuneDepthAlpha(data = d, groupName = "scale", 
                     quantityVarName = "stars", itemVarName = "words",
                     semanticsVarName = "speaker.p", compareDataName = "e11",
                     compareItems = checkWords, alphas = alphas, depths = depths)
```
`rsa.tuneDepthAlpha` returns a list of (`correlation`, `depth`, `alpha`) tuples which an be used for plotting or users can simply sort to find the hyperparamter combination leading to best model fit. Let's take a look at the tuning.
```{r fig.height=8, fig.width=6}
ggplot(results, aes(x = alpha, y = cor, col = as.factor(depth))) +
  geom_point(size = 3) +
  geom_vline(aes(xintercept = results$alpha[1],
             colour = "red",
             linetype = "longdash"))
```

Let's take a look at how RSA performs...
```{r fig.height=8, fig.width=6}
bestModel <- plyr::ddply(.data = peloquinFrank_5Alts, .variables = c("scale"), rsa.runDf, quantityVarName = "stars",
              semanticsVarName = "speaker.p", itemVarName = "words", alpha = 4.5) %>%
  filter(words %in% checkWords)

ggplot(bestModel, aes(x = stars, y = e11, col=words)) +
  geom_point(size=5, alpha=0.5) +
  facet_wrap(~scale) +
  geom_line(aes(y = preds), size=1, lty=4)
```
