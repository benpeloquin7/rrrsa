% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reasoning.R
\name{rsa.tuneDepthAlpha}
\alias{rsa.tuneDepthAlpha}
\title{Tune depth and alpha hyperparamters}
\usage{
rsa.tuneDepthAlpha(data, quantityVarName, semanticsVarName, itemVarName,
  groupName = NA, compareDataName, costsVarName = NA, priorsVarName = NA,
  depths = 1, alphas = 1, compareItems = NA)
}
\arguments{
\item{data, }{tidied data}

\item{semanticsVarName, }{semantic values for inference computation}

\item{itemVarName, }{unique items were comparing, probaby words}

\item{groupName, }{grouping variable if we have one}

\item{compareDataName, }{pragmatic judgments we're comparing to}

\item{costsVarName, }{costs variable name}

\item{priorsVarName, }{priors variable name}

\item{depths, }{vector of depths (in integers) for tuning}

\item{alphas, }{vector of alphas for tuning}

\item{compareItems, }{specific items (in itemVarName col) for data subsetting}

\item{quanityVarName, }{entity name we're quantifying over}
}
\value{
list of length(alphas) * length(depths) tuples with (correlation, depth, alpha)
}
\description{
Return a list with number of alpha * depths elements
each element includes a tuple of (correlation, alpha, depth).
Same basic call functionality as \code{runDf()}
}
\examples{
d <- peloquinFrank_5Alts
alphas <- seq(1, 3, by = 0.1)
depths <- 1:3
checkWords <- c("some", "all", "good", "excellent", "liked", "loved", "memorable", "unforgettable",
"palatable", "delicious")
results <- rsa.tuneDepthAlpha(data = d, groupName = "scale",
quantityVarName = "stars", itemVarName = "words",
semanticsVarName = "speaker.p", compareDataName = "e11",
compareItems = checkWords, alphas = alphas, depths = depths)
head(results)
best <- which.max(unlist(lapply(results, function(i) i[[1]][1])))
results[[best]]

}
\keyword{data}
\keyword{tuning}

